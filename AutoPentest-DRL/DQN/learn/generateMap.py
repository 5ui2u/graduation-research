from graphviz import Source
import csv
import numpy as np
import re

np.set_printoptions(threshold=np.inf) #thresholdを無限大に設定→常に省略されずすべての要素が表示

class generateMap(object): #
#confirm_path.pyで使用
    def __init__(self):
        pass

    def createMatrix(self):
        self.desAttackList = []
        self.srcAttackList = []
        self.rewardList = []
        self.rewardDict = {}
        self.qq = {}

        #attack-graphの情報は format: VERTICES.CSV and ARCS.CSV で出力される
        self.csvfile = open('../mulval_result/VERTICES.CSV', 'r') #VERTICESのcsvファイルを開く
        self.arcscsv = open('../mulval_result/ARCS.CSV', 'r') #ARCSのcsvファイルを開く
        #readlines:ファイルの中身全て読み込み、結果は文字列のリスト
        self.arcsCsvData = self.arcscsv.readlines() #ARCSの文字列リスト
        self.allCsvData = self.csvfile.readlines() #VERTICESの文字列リスト

        self.endLine = self.allCsvData[-1] #リストの最後の値を取得
        self.line=int(self.endLine.split(',')[0]) #文字列を,(コンマ)で区切る
        
        self.MAP = -(np.ones((self.line, self.line), dtype=np.float)) #要素が1の配列を生成する関数numpy.ones(配列の形状(),要素のデータ型)
        
        self.i = 0 #
        for self.csvdata in self.allCsvData: #VERTICESの文字列リストから一つずつ要素を取り出す
            if(len(re.findall('execCode', self.csvdata)) > 0): #execCodeにVERTICESと同じ要素がある時
                if(self.i == 0): #配列の要素1つ目の時
                    self.rewardList.append(100.0) #配列rewardListに要素100.0を追加
                    self.rewardDict[self.i] = 100.0 #辞書rewardDictに{i:100}
                else: #配列の要素2つ目以降
                    self.rewardList.append(0.3) #配列rewardListに要素100.0を追加
                    self.rewardDict[self.i] = 0.3 #辞書rewardDictに{i:0.3}

            elif(len(re.findall('vulExists', self.csvdata)) > 0): #vulExistsにVERTICESと同じ要素がある時

                self.cveNumber = self.csvdata.split('(')[1].split(',')[1].split("'")[1] #
                self.cve_base_score, self.cve_exploitablity_score = self.get_cvss_score(self.cveNumber) #
                
                self.cvss_score = self.cve_base_score * (self.cve_exploitablity_score/10) #
                self.rewardList.append(self.cvss_score) #
                self.rewardDict[self.i] = self.cvss_score #
                self.qq[self.i] = self.cvss_score #
           
            elif(len(re.findall('attackerLocated', self.csvdata)) > 0): #attackerLocatedにVERTICESと同じ要素がある時
                self.startLabel = self.csvdata.split('(')[1].split(')')[0] #
                if(self.startLabel == 'internet'): #
                    self.rewardList.append(0.01) #配列rewardListに0.01を追加
                    self.rewardDict[self.i] = 0.01 #辞書rewardDict{i:0.01}

            else: #VERTICESと同じ要素がない時
                self.rewardList.append(0.1) #配列rewardListに0.1を追加
                self.rewardDict[self.i] = 0.1 #辞書rewardDict{i:0.1}
        
            self.i = self.i + 1 #iを1増やす
        for self.data in self.allCsvData: #VERTICESの文字列リストから一つずつ要素を取り出す
            if(len(re.findall('RULE 2', self.data)) > 0): #VERTICESに`RULE 2`要素がある時
                for self.a in self.qq: #
                    for self.b in self.arcsCsvData: #
                        if int(self.a) == int(self.b.split(',')[1]) - 1 : #
                            if self.allCsvData.index(self.data) == int(self.b.split(',')[0]) - 1: #
                                self.rewardDict[self.allCsvData.index(self.data)] = self.qq[self.a] #
                                
        self.txtfile = open('../mulval_result/AttackGraph.txt', 'r') #AttackGraph.txtを開く
        self.allTxtData = self.txtfile.readlines() #AttackGraph.txtを読み込む

        for self.txtdata in self.allTxtData: #AttackGraph.txt(des,src)を1行ずつ抽出
            if(len(re.findall('"', self.txtdata)) == 0): # " で部分文字列を抽出
                self.desAttack = int(self.txtdata.split(',')[0]) #desの配列番号を抜き出す
                self.srcAttack = int(self.txtdata.split(',')[1]) #srcの配列番号を抜き出す
                self.desAttackList.append(self.desAttack) #desをリストに追加
                self.srcAttackList.append(self.srcAttack) #srcをリストに追加

                self.state = [(self.srcAttack - 1), (self.desAttack - 1)]  #state=AttackGraph.txt(des,src)
                #-1は配列番号と文字列の番号に1のずれがあるため
                self.location = self.MAP[tuple(self.state)] #location

           
                if(self.srcAttack > self.desAttack): #
                    if(self.rewardDict[self.srcAttack - 1] == 0.01): #attackerLocated
                   
                        self.MAP[tuple(self.state)] = self.rewardDict[self.srcAttack - 1] #src
                    elif(self.rewardDict[self.desAttack - 1] == 100.0): #execCode
                        self.MAP[tuple(self.state)] = self.rewardDict[self.desAttack - 1] #des
                    else: #
                        self.MAP[tuple(self.state)] = (self.rewardDict[self.srcAttack - 1] + self.rewardDict[self.desAttack - 1])
                else:
                    self.MAP[tuple(self.state)] = 0.0 #MAPを0.0に

                
        return self.MAP #MAPを返す

    def get_cvss_score(self, cveNumber): #関数
        with open('../Database/CVE_Info_Dataset.csv', 'r') as self.csvfile: #/Database/CVE_Info_Dataset.csvを開く
            self.allCveData = csv.reader(self.csvfile) #CVE_Info_Dataset.csvを読み込み
            for self.cvedata in self.allCveData: #csvを１行ずつ抽出
                if self.cveNumber == self.cvedata[0]: #CVEが一致する時
                    self.cve_base_score = float(self.cvedata[2]) #CVEのベーススコア
                    self.cve_exploitablity_score = float(self.cvedata[3]) #exploitablity:悪用可能性のスコア
                    return self.cve_base_score, self.cve_exploitablity_score #ベーススコア,悪用可能性のスコアを返す
                    
    @property #プロパティ:外から簡単に値を変えられない上に、取り出しは簡単にしたい時に役立つもの
    def sendMap(self): #攻撃MAPを送信する関数
        self.x = self.createMatrix() #関数createMatrixを実行
        return self.x
