import os
import sys
import time
import json
import csv
from jinja2 import Environment, PackageLoader, select_autoescape, FileSystemLoader
import torch
from random import choice

# 各種操作モードで使用するファイル(ファイル変更した場合はここのファイル名を変更すればよい)
TOPOLOGY_PATH = "MulVAL_P/"
LOGICAL_ATTACK_TOPOLOGY = "logical_topology_1.P" #→論理モードのみ使用
GENERATION_TOPOLOGY_TEMPLATE = "topology_template.P" # Topology_generator/topo_proc.pyも定義する→論理モードのみ使用
GENERATION_TOPOLOGY_FINAL = "topology_generated.P" #→論理モードのみ使用
REAL_ATTACK_TOPOLOGY = "real_topology_1.P" # Nmap_scan/create_top.pyも定義する

# 脆弱性を持つサーバーデータのリスト
filedataList = [] #fileのデータリスト
webdataList = [] #webのデータリスト
firedataList = [] #firewallのデータリスト


def createTemp_tem(): #テンプレートをつくる関数
    
    env = Environment(loader=FileSystemLoader('./'+TOPOLOGY_PATH), autoescape=select_autoescape('P')) #ネットワーク環境(トポロジのパスを保持)
    template_gen = env.get_template(GENERATION_TOPOLOGY_TEMPLATE) #トポロジのテンプレを取得

    fileTemp = list(choice(filedataList)) #choice:リストからランダムに要素を選択する
    webTemp = list(choice(webdataList)) #
    fireTemp = list(choice(firedataList)) #

    baiscFile = open('./' + TOPOLOGY_PATH + GENERATION_TOPOLOGY_FINAL, 'w') #

    basic_temp = template_gen.render(CVE_Id_Web=webTemp[3], Web_Module=webTemp[0], Web_Transport=webTemp[1],
                                            Web_Port=webTemp[2], Web_Product=webTemp[4], 
                                            CVE_Id_File=fileTemp[3], File_Module=fileTemp[0], 
                                            File_Transport=fileTemp[1], File_Port=fileTemp[2],
                CVE_Id_Fire=fireTemp[3], Fire_Module=fireTemp[0], Fire_Transport=fireTemp[1], 
                                            Fire_Port=fireTemp[2], Fire_Product=fireTemp[4], )


    baiscFile.write(basic_temp)
    baiscFile.close() 
    print("Saved logical topology in '{}'.".format(TOPOLOGY_PATH + GENERATION_TOPOLOGY_FINAL))


def saveVul(): #csvデータから脆弱性の情報を読み込み,リストに格納する関数

    print('Open preprocessed server data...') #出力:"前処理されたサーバーデータを開く"
    fileProcessFile = open('./Database/ProcessData/fileData_process.csv', 'r') #fileData_process.csvを読み込む
    webProcessFile = open('./Database/ProcessData/webData_process.csv', 'r') #webData_process.csvを読み込む
    msProcessFile = open('./Database/ProcessData/MSData_process.csv', 'r') #MSData_process.csvを読み込む
    fireProcessFile = open('./Database/ProcessData/fireData_process.csv', 'r') #fireData_process.csvを読み込む

    fileProcessData = csv.reader(fileProcessFile) #ファイルのプロセスデータを変数に保持
    webProcessData = csv.reader(webProcessFile) #ウェブのプロセスデータを変数に保持
    msProcessData = csv.reader(msProcessFile) #msのプロセスデータを変数に保持  ms??
    fireProcessData = csv.reader(fireProcessFile) #fireのプロセスデータを変数に保持  fire??

    for filedata in fileProcessData: #filedataはサーバが問題である脆弱性のデータを探す

      #filedata[脆弱性名前CVE,原因,プロトコル名,tcp,ポート番号,サーバソフトウェア名]

        if filedata[1] == 'Permissions, Privileges, and Access Control ': #filedata[1]が"パーミッション、特権、およびアクセス制御"(サーバの問題)の場合
            file_module = filedata[2] #プロトコル名
            file_transport = filedata[3] #tcp
            file_port = filedata[4] #ポート番号
            cve_id_file = filedata[0] #脆弱性名
            file_product = filedata[5] #サーバソフトウェア名

            filedataTuple = (file_module, file_transport, file_port, cve_id_file, file_product) #脆弱性のデータをタプルでまとめる 
            #filedataTuple = (プロトコル名,tcp,ポート番号,脆弱性名,サーバソフトウェア名)
            filedataList.append(filedataTuple) #脆弱性のリストに追加

    webProcessFile.seek(0) #ファイルの読み込みの位置を始めにもどす
    for webdata in webProcessData: #webdataからサーバが問題である脆弱性のデータを探す

        if webdata[1] == 'Permissions, Privileges, and Access Control ': #webdata[1]が"パーミッション、特権、およびアクセス制御"(サーバの問題)の場合
            web_module = webdata[2] #プロトコル名
            web_transport = webdata[3] #tcp
            web_port = webdata[4] #ポート番号
            cve_id_web = webdata[0] #脆弱性名
            web_product = webdata[5] #サーバソフトウェア名

            webdataTuple = (web_module, web_transport, web_port, cve_id_web, web_product) #脆弱性のデータをタプルでまとめる 
            #webdataTuple = (プロトコル名,tcp,ポート番号,脆弱性名,サーバソフトウェア名)
            webdataList.append(webdataTuple) #脆弱性のリストに追加

    fireProcessFile.seek(0) #ファイルの読み込みの位置を始めにもどす
    for firedata in fireProcessData: #firedataからサーバが問題である脆弱性のデータを探す

        if firedata[1] == 'Permissions, Privileges, and Access Control ': #firedata[1]が"パーミッション、特権、およびアクセス制御"(サーバの問題)の場合
            fire_module = firedata[2] #プロトコル名
            fire_transport = firedata[3] #tcp
            fire_port = firedata[4] #ポート番号
            cve_id_fire = firedata[0] #脆弱性名
            fire_product = firedata[5] #サーバソフトウェア名

            firedataTuple = (fire_module, fire_transport, fire_port, cve_id_fire, fire_product) #脆弱性のデータをタプルでまとめる 
            #webdataTuple = (プロトコル名,tcp,ポート番号,脆弱性名,サーバソフトウェア名)
            firedataList.append(firedataTuple) ##脆弱性のリストに追加

    fileProcessFile.close() #ファイルを閉じる
    webProcessFile.close() #ファイルを閉じる
    msProcessFile.close() #ファイルを閉じる
    fireProcessFile.close() #ファイルを閉じる

    print('Vulnerability information loaded.') #出力:"脆弱性情報を読み込みました"


def startTrain(model): #学習を開始する関数
    
    if not os.path.exists('./DQN/saved_model'): #学習モデルのパスが存在しているか確認
        os.system('mkdir ./DQN/saved_model') #パスが存在しない場合,パスを作成

    if os.path.exists('./DQN/saved_model/dqn_model.pt'): #dqnモデルのパスが存在しているか確認
        os.system('rm ./DQN/saved_model/dqn_model.pt') #パスが存在する場合、dqnモデルのパスを消す
        print("Removed previous DQN model in 'DQN/saved_model/dqn_model.pt'.") #出力:"以前のDQNモデルを削除"

    if model == 'logical_attack': #modelが論理アタックの場合
        print("Generate attack graph using MulVAL...") #出力:"MulVALを使用して攻撃グラフを生成..."
        os.system('rm -f ./mulval_result/*.*') #mulvalの結果を削除
        os.chdir('./mulval_result') #カレントディレクトリを./mulval_resultへ移動
        os.system('../repos/mulval/utils/graph_gen.sh ../' + TOPOLOGY_PATH + LOGICAL_ATTACK_TOPOLOGY + ' -v > /dev/null') #
        #対象のサーバへsshしたあと、ホームディレクトリをlsした結果を、スクリプト実行側へrsyncで同期
        os.chdir('../') #ホームディレクトリに戻る
        os.chdir('./DQN') #DQNディレクトリに移動
        print("Process attack graph into attack matrix...") #出力:"攻撃グラフを攻撃マトリックスに処理..."
        os.system('python3 ./confirm_path.py') #confirm_path.pyを実行
        os.chdir('./learn') #learnディレクトリに移動
        status = os.system('python3 ./dqn_learn.py train') #dqn_learn.py trainを実行
        os.chdir('../../') #ホームディレクトリに移動
        if os.WIFSIGNALED(status): #プロセスが途中で中断した場合
            print("Interrupted while conducting DQN training => exit") #出力:DQN調教中に中断
    elif model == 'logical_attack_gen': #modelが論理アタック生成の場合
        print("Generate attack graph using MulVAL...") #出力:MulVAL を使用して攻撃グラフを生成
        os.system('rm -f ./mulval_result/*.*') #
        os.chdir('./mulval_result') #mulvalの結果を削除
        os.system('../repos/mulval/utils/graph_gen.sh ../' + TOPOLOGY_PATH + GENERATION_TOPOLOGY_FINAL + ' -v > /dev/null') #
        #対象のサーバへsshしたあと、ホームディレクトリをlsした結果を、スクリプト実行側へrsyncで同期
        os.chdir('../') #ホームディレクトリに移動
        os.chdir('./DQN') #DQNディレクトリに移動
        print("Process attack graph into attack matrix...") #出力:攻撃グラフを攻撃マトリックスに処理
        os.system('python3 ./confirm_path.py') #confirm_path.pyを実行
        os.chdir('./learn') #learnディレクトリに移動
        status = os.system('python3 ./dqn_learn.py train') #dqn_learn.py trainを実行
        os.chdir('../../') #ホームディレクトリに移動
        if os.WIFSIGNALED(status): #プロセスが途中で中断した場合
            print("Interrupted while conducting DQN training => exit") #出力:DQN調教中に中断
    elif model == 'nmap': #modelがnmapの場合
        print("Process attack graph into attack matrix...") #出力:攻撃グラフを攻撃マトリックスに処理
        os.chdir('./DQN') #DQNディレクトリに移動
        os.system('python3 ./confirm_path.py') #confirm_path.pyを実行
        os.chdir('./learn') #learnディレクトリに移動
        status = os.system('python3 ./dqn_learn.py nmap') #dqn_learn.py nmapを実行
        os.chdir('../../') #ホームディレクトリに移動
        if os.WIFSIGNALED(status): #プロセスが途中で中断した場合
            print("Interrupted while conducting DQN training => exit") #出力:DQN調教中に中断


def startTrainCode(model):#学習を実行する関数

    if model == 'logical_attack': #modelが論理アタックの場合
        print("--------------------------------------------------------------------------------")
        print("AutoPentest-DRL: Compute attack path for logical network...") #出力:論理ネットワークの攻撃パスを計算する
        env = Environment(loader=FileSystemLoader('./'+TOPOLOGY_PATH), autoescape=select_autoescape('P')) #
        template = env.get_template(LOGICAL_ATTACK_TOPOLOGY) #テンプレを取得
        startTrain('logical_attack') #論理アタックで学習開始
    elif model == 'logical_attack_gen': #modelが論理アタック生成の場合
        print("--------------------------------------------------------------------------------")
        print("AutoPentest-DRL: Load vulnerability information...") #出力:脆弱性情報を読み込む
        saveVul() #脆弱性を読み込む
        print("--------------------------------------------------------------------------------")
        print("AutoPentest-DRL: Populate topology with vulnerabilities...") #出力:トポロジに脆弱性を設定
        createTemp_tem() #テンプレートを作成
        print("--------------------------------------------------------------------------------")
        print("AutoPentest-DRL: Compute attack path for generated logical network...") #出力:生成された論理ネットワークの攻撃経路を計算する
        startTrain('logical_attack_gen') #論理アタック生成で学習開始


def startTemCode(): #テンプレートを実行する関数
    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Create random topology using topology-generator...") #topology-generator を使用してランダムトポロジを作成する
    os.chdir('./Topology_generator/topology-generator') #topology-generatorディレクトリに移動
    os.system('python2 topo-gen.py -c ../topo-gen-config -o top_info') #topo-gen.py -cを実行
    print("Saved topology in 'Topology_generator/topology-generator/top_info_1.json'.") #出力:トポロジを保存しました

    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Convert random topology to MulVAL topology...") #ランダムトポロジをMULVALトポロジに変換する
    os.chdir('../') #ホームディレクトリへ移動
    status = os.system('python3 topo_proc.py') #topo_proc.pyを実行
    os.chdir('../') #ホームディレクトリに移動
    if os.WEXITSTATUS(status) != 0: #プロセスの終了ステータスが0でない場合
        print("AutoPentest-DRL: Random topology generation failed => abort") #出力ランダムトポロジの生成に失敗
        return

    startTrainCode('logical_attack_gen') #論理アタック生成で学習開始


def startRealAttackCode(): #リアルアタックモードを開始
    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Get vulnerabilities in target network using Nmap...") #出力:Nmapを使用してターゲットネットワークの脆弱性を取得する
    os.chdir('./Nmap_scan') #Nmap_scanディレクトリに移動
    status = os.system('python3 create_top.py') #create_top.pyを実行
    if os.WEXITSTATUS(status) != 0: #プロセスの終了ステータスが0でない場合
        print("AutoPentest-DRL: Nmap scanning failed => abort") #出力:Nmapのスキャンを失敗しました
        return

    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Generate attack graph using MulVAL...") #MulVALを使用して攻撃グラフを生成する
    os.system('rm -f ../mulval_result/*.*') #mulval_resultファイル内のデータを削除
    os.chdir('../mulval_result') #mulval_resultのディレクトリへ移動
    os.system('../repos/mulval/utils/graph_gen.sh ../Nmap_scan/attack.P -v') #graph_gen.shを実行後 attack.P入力 -visualize

    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Compute attack path for real network...") #実際のネットワークの攻撃経路を計算する
    os.chdir('../') #ホームディレクトリへ移動
    startTrain('nmap') #nmapで学習開始

    print("--------------------------------------------------------------------------------")
    print("AutoPentest-DRL: Perform penetration testing using Metasploit...") #Metasploit を使用して侵入テストを実行する
    os.chdir('./Penetration_tools') #Penetration_toolsディレクトリに移動
    os.system('python3 ./start_attack.py') #start_attack.pyを実行
    os.chdir('../') #ホームディレクトリに移動


def start_function(model): #操作モードを選択する関数

    if model == 'logical_attack': #modelが論理アタックモードの場合
        print("AutoPentest-DRL: Operation mode:  {}".format("Attack on logical network"))
        print("AutoPentest-DRL: Target topology: {}".format(TOPOLOGY_PATH + LOGICAL_ATTACK_TOPOLOGY))
        startTrainCode('logical_attack')
    elif model == 'logical_attack_gen': #modelが論理アタックモード生成の場合
        print("AutoPentest-DRL: Operation mode:  {}".format("Attack on generated logical network"))
        print("AutoPentest-DRL: Target topology: {}".format(TOPOLOGY_PATH + GENERATION_TOPOLOGY_FINAL))
        startTemCode()
    elif model == 'real_attack': #modelがリアルアタックモードの場合
        print("AutoPentest-DRL: Operation mode:  {}".format("Attack on real network")) #出力:Operation mode "Attack on real network"
        print("AutoPentest-DRL: Target topology: {}".format(TOPOLOGY_PATH + REAL_ATTACK_TOPOLOGY)) #出力:Target topology
        startRealAttackCode() #リアルアタックモードを開始
    else: #それ以外の場合
        print("AutoPentest-DRL: ERROR: Unrecognized operation mode: {}".format(model)) #出力:エラー操作モードが不明


if __name__ == '__main__':
    try:
        print("################################################################################")
        print("AutoPentest-DRL: Automated Penetration Testing Using Deep Reinforcement Learning") #出力:深層強化学習を使用した自動侵入テスト
        print("################################################################################")
        if len(sys.argv) != 2: #sys.argvは,Pythonスクリプトに渡されたコマンドライン引数のリスト が2でない場合
            print("ERROR: The operation mode must be specified:") #出力:操作モードを指定する必要があります
            print("       $ python3 ./AutoPentest-DRL.py <OPERATION_MODE>") #コマンドOP(1)
            print("OPERATION MODES:") #コマンドOP(2)
            print("       logical_attack:  Attack on logical network topology") #コマンドOP(3)
            print("       real_attack:     Attack on real network topology") #コマンドOP(4)
            sys.exit(2) #終了
        model = str(sys.argv[1]) #modelに2つ目の引数を代入(logical_attack or real_attack)
        start_function(model) #指定した操作モードの開始
    except KeyboardInterrupt: #キーボード打ち込みミスの場合
        print ("\nAutoPentest-DRL: Keyboard interrupt detected => end execution")
        sys.exit(1) #終了
